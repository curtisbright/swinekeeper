// file      : InputDevices.h
// begin     : Jul 30 2000
// copyright : (C) 2000 by Hans Kopp
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

#ifndef INPUTDEVICES_H_INCLUDED
#define INPUTDEVICES_H_INCLUDED

#include <minebase/MineBase.h>
#include <mineuibase/UIDrawContext.h>
#include "CGameView.h"

/** 
 * Base class for things that are able to push fields of the minesweeper array. 
 * 
 * Subclasses of this class get primitive device events from 
 * the client and use these events to create a mouse-like behaviour. 
 * They will call the 'controller-methods' of @ref CGameView 
 * (e.g. @ref CGameView::onPushField) 
 * A input device is able to display some informations about its current state. 
 */ 
class CInputDeviceBase {
public: 
   /** 
    * Set the view the input device should operator on. 
    */ 
   virtual void setView(CGameView *pView)=0; 
   /** 
    * If the input device has a 'current position', this function 
    * returns it. 
    * @return true, iff the function has a current position
    */  
   virtual bool getCurFieldPos(CFieldPos &p) const=0; 
   /** 
    * Draw the current state of the input device
    */ 
   virtual void draw(CUIDrawContextBase *pCtx, bool bForceUpdate)=0;   
   /** 
    * The input device can decide which parts of the CGameView it 
    * wants to be refreshed before it is drawn itself. 
    * Usually it has to force a refresh of things it has overdrawn 
    * in the previous iteration. 
    */ 
   virtual void getUpdateViewInfo(CGameView::CUpdateViewInfo &viewInfo) const=0; 
   /** 
    * Returns a value that describes if the smilie button is pushed ... 
    */ 
   virtual void getViewDeviceStateInfo(CGameView::CDeviceStateInfo &state) const=0; 

   virtual ~CInputDeviceBase() {}
}; 

/** 
 * Input device for mouses. 
 */ 
class CMouseInputDevice : public CInputDeviceBase {
public: 
   
   enum MouseButton {
      BUTTON_NONE, 
      BUTTON_LEFT, 
      BUTTON_MIDDLE, 
      BUTTON_RIGHT
   }; 
   CMouseInputDevice(CGameView *pView=NULL) : 
      m_pView(pView)
   {}
   void setView(CGameView *pView) {m_pView = pView;}

   virtual bool getCurFieldPos(CFieldPos &p) const; 
   virtual CGameView::MouseButton getCurMouseButton() const; 
   virtual bool isSmiliePushed() const;
   virtual void draw(CUIDrawContextBase *pCtx, bool bForceUpdate); 
   virtual bool hasStateChanged() const; 

   virtual void getUpdateViewInfo(CGameView::CUpdateViewInfo &viewInfo) const; 
   virtual void getViewDeviceStateInfo(CGameView::CDeviceStateInfo &state) const; 

   // primitive events that are generated by the client of this class 
   void onPushButton(const CUIPoint &mousePos, MouseButton nButton); 
   void onReleaseButton(const CUIPoint &mousePos); 
   void onMoveMouse(const CUIPoint &mousePos); 
   

private: 
   CGameView *m_pView; 

   /** 
    * A class that describes the current state of the mouse. 
    * Used to determine if the state has changed between two 
    * subsequent iterations
    */ 
   struct CDeviceState {
      bool m_bHasFieldPos;
      CFieldPos m_fieldPos; 
      MouseButton m_nButton; 
      bool n_bIsSmiliePushed; 
      CDeviceState() : 
         m_bHasFieldPos(false),
         m_nButton(BUTTON_NONE),
         n_bIsSmiliePushed(false) {}
      bool operator==(const CDeviceState &ds2) const {
         return m_bHasFieldPos==ds2.m_bHasFieldPos 
             && m_fieldPos==ds2.m_fieldPos
             && m_nButton==ds2.m_nButton
             && n_bIsSmiliePushed==ds2.n_bIsSmiliePushed; 
      }
   }; 

   CDeviceState m_curState, m_lastState; 

   void redraw(
      CUIDrawContextBase *pCtx); 

   static CGameView::MouseButton toGameView(MouseButton nButton); 
}; 


#endif 
